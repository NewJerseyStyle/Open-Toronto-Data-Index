<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Toronto Open Data QA</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <script src="https://unpkg.com/marked@11.0.0/marked.min.js"></script>
    <style>
        @keyframes pulse-slow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .animate-pulse-slow {
            animation: pulse-slow 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        pre code {
            display: block;
            overflow-x: auto;
            padding: 0.5rem;
            background: #f3f4f6;
            border-radius: 0.375rem;
        }
        .dark pre code {
            background: #1f2937;
        }
    </style>
</head>
<body class="h-full bg-gray-50 dark:bg-gray-900">
    <!-- API Key Modal -->
    <div id="apiKeyModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-8 rounded-lg shadow-xl max-w-md w-full mx-4">
            <h2 class="text-2xl font-bold text-gray-900 dark:text-white mb-4">Welcome!</h2>
            <p class="text-gray-600 dark:text-gray-400 mb-4">
                This app uses Claude to analyze Toronto Open Data. You'll need an Anthropic API key.
            </p>
            
            <div class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4 mb-4">
                <p class="text-sm text-blue-800 dark:text-blue-200">
                    <strong>Get a free key:</strong> 
                    <a href="https://console.anthropic.com/" target="_blank" class="underline hover:text-blue-600">console.anthropic.com</a>
                </p>
            </div>

            <label for="apiKeyInput" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                Anthropic API Key
            </label>
            <input
                type="password"
                id="apiKeyInput"
                placeholder="sk-ant-..."
                class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-[#5D5CDE] dark:bg-gray-700 dark:text-white mb-2"
            >
            <p class="text-xs text-gray-500 dark:text-gray-400 mb-4">
                Your key is stored locally and only sent to Anthropic's API.
            </p>

            <div class="flex justify-end gap-3">
                <button id="apiKeyCancel" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg">
                    Cancel
                </button>
                <button id="apiKeySave" class="px-4 py-2 bg-[#5D5CDE] text-white rounded-lg hover:bg-[#4D4CCE]">
                    Save
                </button>
            </div>
        </div>
    </div>

    <div id="app" class="h-full flex flex-col">
        <!-- Header -->
        <header class="bg-white dark:bg-gray-800 shadow-sm border-b border-gray-200 dark:border-gray-700">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
                <div class="flex items-center justify-between">
                    <div>
                        <h1 class="text-2xl font-bold text-gray-900 dark:text-white">Toronto Open Data QA</h1>
                        <p class="text-sm text-gray-600 dark:text-gray-400 mt-1">AI-powered analysis with full transparency</p>
                    </div>
                    <div class="flex gap-2">
                        <button id="changeKeyBtn" class="px-4 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700">
                            Change Key
                        </button>
                        <button id="clearAllBtn" class="px-4 py-2 text-sm border border-red-300 dark:border-red-600 text-red-600 dark:text-red-400 rounded-lg hover:bg-red-50 dark:hover:bg-red-900/20">
                            Clear All
                        </button>
                    </div>
                </div>
            </div>
        </header>

        <!-- Main -->
        <main class="flex-1 overflow-hidden flex flex-col max-w-7xl mx-auto w-full px-4 sm:px-6 lg:px-8 py-6">
            <!-- Question Input -->
            <div class="mb-6">
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-4">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                        Ask a question
                    </label>
                    <div class="flex gap-2">
                        <input
                            type="text"
                            id="questionInput"
                            placeholder="e.g., What are the top 5 most dangerous intersections in Toronto?"
                            class="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-[#5D5CDE] dark:bg-gray-700 dark:text-white"
                        >
                        <button id="askBtn" class="px-6 py-2 bg-[#5D5CDE] text-white rounded-lg hover:bg-[#4D4CCE] disabled:opacity-50">
                            Ask
                        </button>
                    </div>
                </div>
            </div>

            <!-- Status -->
            <div id="statusArea" class="mb-4 hidden">
                <div class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
                    <div class="flex items-start gap-3">
                        <div class="animate-pulse-slow">
                            <svg class="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                        </div>
                        <p id="statusText" class="text-sm text-blue-800 dark:text-blue-200"></p>
                    </div>
                </div>
            </div>

            <!-- Error -->
            <div id="errorArea" class="mb-4 hidden">
                <div class="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4">
                    <div class="flex items-start gap-3">
                        <svg class="w-5 h-5 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                        <p id="errorText" class="text-sm text-red-800 dark:text-red-200"></p>
                    </div>
                </div>
            </div>

            <!-- Three Column Layout -->
            <div class="flex-1 grid grid-cols-1 lg:grid-cols-3 gap-6 overflow-hidden">
                <!-- Left: Answer -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6 overflow-auto">
                    <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Answer</h2>
                    <div id="answerArea" class="prose prose-sm dark:prose-invert max-w-none">
                        <p class="text-gray-600 dark:text-gray-400 italic">Your answer will appear here...</p>
                    </div>
                </div>

                <!-- Middle: Dataset Selection & Loading -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6 overflow-auto">
                    <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Datasets</h2>
                    
                    <!-- Selected Datasets -->
                    <div id="selectedDatasetsSection" class="mb-6 hidden">
                        <h3 class="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">Selected for Analysis</h3>
                        <div id="selectedDatasets" class="space-y-2"></div>
                    </div>

                    <!-- Loaded Datasets -->
                    <div id="loadedDatasetsSection" class="mb-6 hidden">
                        <h3 class="text-sm font-semibold text-green-700 dark:text-green-300 mb-2">Successfully Loaded</h3>
                        <div id="loadedDatasets" class="space-y-2"></div>
                    </div>

                    <!-- Failed Datasets -->
                    <div id="failedDatasetsSection" class="mb-6 hidden">
                        <h3 class="text-sm font-semibold text-red-700 dark:text-red-300 mb-2">Failed to Load</h3>
                        <div id="failedDatasets" class="space-y-2"></div>
                    </div>

                    <p id="datasetsPlaceholder" class="text-sm text-gray-600 dark:text-gray-400 italic">Dataset information will appear here...</p>
                </div>

                <!-- Right: SQL Queries & Results -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6 overflow-auto">
                    <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">
                        Queries & Results
                        <button id="copyAllBtn" class="ml-2 px-2 py-1 text-xs bg-gray-100 dark:bg-gray-700 rounded hover:bg-gray-200 dark:hover:bg-gray-600 hidden">
                            Copy All
                        </button>
                    </h2>
                    <div id="queriesArea" class="space-y-4">
                        <p class="text-sm text-gray-600 dark:text-gray-400 italic">SQL queries and results will appear here...</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script type="module">
        import * as duckdb from 'https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.30.0/+esm';
        
        window.duckdb = duckdb;
        marked.setOptions({ breaks: true, gfm: true });

        const state = {
            db: null,
            apiKey: null,
            isProcessing: false,
            selectedDatasets: [],
            loadedDatasets: [],
            failedDatasets: [],
            queries: []
        };

        // === API Key Management ===
        function showApiKeyModal() {
            document.getElementById('apiKeyModal').classList.remove('hidden');
            document.getElementById('apiKeyInput').focus();
        }

        function hideApiKeyModal() {
            document.getElementById('apiKeyModal').classList.add('hidden');
        }

        function saveApiKey() {
            const key = document.getElementById('apiKeyInput').value.trim();
            if (!key || !key.startsWith('sk-ant-')) {
                alert('Please enter a valid API key starting with "sk-ant-"');
                return;
            }
            localStorage.setItem('anthropic_api_key', key);
            state.apiKey = key;
            hideApiKeyModal();
            initDuckDB();
        }

        window.addEventListener('DOMContentLoaded', () => {
            const savedKey = localStorage.getItem('anthropic_api_key');
            if (savedKey) {
                state.apiKey = savedKey;
                initDuckDB();
            } else {
                showApiKeyModal();
            }
        });

        document.getElementById('apiKeySave').addEventListener('click', saveApiKey);
        document.getElementById('apiKeyCancel').addEventListener('click', () => {
            if (!state.apiKey) alert('An API key is required');
            else hideApiKeyModal();
        });
        document.getElementById('apiKeyInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') saveApiKey();
        });
        document.getElementById('changeKeyBtn').addEventListener('click', showApiKeyModal);

        // === Claude API ===
        async function callClaude(prompt, systemPrompt = '', useSystemPromptFile = null) {
            if (!state.apiKey) throw new Error('No API key');

            let finalSystemPrompt = systemPrompt;
            if (useSystemPromptFile) {
                try {
                    const response = await fetch(`prompts/${useSystemPromptFile}.md`);
                    if (response.ok) {
                        finalSystemPrompt = await response.text();
                    }
                } catch (e) {
                    console.warn('Could not load system prompt file:', e);
                }
            }

            const response = await fetch("https://api.anthropic.com/v1/messages", {
                method: "POST",
                headers: {
                    "x-api-key": state.apiKey,
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({
                    model: "claude-sonnet-4-5",
                    max_tokens: 4000,
                    messages: [{ role: "user", content: prompt }],
                    ...(finalSystemPrompt && { system: finalSystemPrompt })
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || 'API call failed');
            }

            const data = await response.json();
            return data.content[0].text;
        }

        // === DuckDB ===
        async function initDuckDB() {
            try {
                showStatus('Initializing database...');

                const JSDELIVR_BUNDLES = window.duckdb.getJsDelivrBundles();
                const bundle = await window.duckdb.selectBundle(JSDELIVR_BUNDLES);
                const worker = await window.duckdb.createWorker(bundle.mainWorker);
                const logger = new window.duckdb.ConsoleLogger();
                const db = new window.duckdb.AsyncDuckDB(logger, worker);
                await db.instantiate(bundle.mainModule, bundle.pthreadWorker);

                state.db = db;
                
                const conn = await db.connect();
                try {
                    await conn.query("INSTALL httpfs; LOAD httpfs;");
                    await conn.query(`
                        ATTACH 'https://cdn.jsdelivr.net/gh/NewJerseyStyle/Open-Toronto-Data-Index/opendata.db' AS toronto_db;
                        USE toronto_db;
                    `);
                } finally {
                    await conn.close();
                }
                
                hideStatus();
                updateAnswer('**Ready!** Ask a question about Toronto open data.');
            } catch (error) {
                console.error('Init error:', error);
                showError('Failed to initialize: ' + error.message);
            }
        }

        async function executeQuery(sql) {
            const conn = await state.db.connect();
            try {
                const result = await conn.query(sql);
                return result.toArray();
            } finally {
                await conn.close();
            }
        }

        // === Docling Conversion ===
        async function convertWithDocling(fileUrl) {
            try {
                const postResponse = await fetch('https://yasserrmd-doclingconverter.hf.space/gradio_api/call/convert_document', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        data: [{ path: fileUrl }, "Markdown"]
                    })
                });

                const postData = await postResponse.json();
                const eventId = postData.event_id;
                
                if (!eventId) throw new Error('No event ID returned');

                const getResponse = await fetch(`https://yasserrmd-doclingconverter.hf.space/gradio_api/call/convert_document/${eventId}`);
                
                const reader = getResponse.body.getReader();
                const decoder = new TextDecoder();
                let result = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                if (data[0]) result = data[0];
                            } catch (e) {}
                        }
                    }
                }

                if (!result) throw new Error('No result from Docling');
                return result;
            } catch (error) {
                throw new Error(`Docling conversion failed: ${error.message}`);
            }
        }

        // === Helper Functions ===
        function cleanMarkdownSummary(markdown) {
            const lines = markdown.split('\n');
            const seen = new Set();
            const cleaned = [];
            
            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed) continue;
                if (trimmed.match(/^(toronto|city of toronto|open data|dataset|download|share)/i)) continue;
                if (seen.has(trimmed)) continue;
                
                seen.add(trimmed);
                cleaned.push(line);
            }
            
            return cleaned.join('\n');
        }

        function extractDownloadLinks(markdown) {
            const links = [];
            const regex = /\[Download\s+\([^\)]+\)\]\((https?:\/\/[^\)]+)\)/gi;
            let match;
            
            while ((match = regex.exec(markdown)) !== null) {
                links.push(match[1]);
            }
            
            return links;
        }

        function showStatus(msg) {
            document.getElementById('statusText').textContent = msg;
            document.getElementById('statusArea').classList.remove('hidden');
        }

        function hideStatus() {
            document.getElementById('statusArea').classList.add('hidden');
        }

        function showError(msg) {
            document.getElementById('errorText').textContent = msg;
            document.getElementById('errorArea').classList.remove('hidden');
        }

        function hideError() {
            document.getElementById('errorArea').classList.add('hidden');
        }

        function updateAnswer(text) {
            document.getElementById('answerArea').innerHTML = marked.parse(text);
        }

        function updateDatasetDisplay() {
            // Selected Datasets
            const selectedSection = document.getElementById('selectedDatasetsSection');
            const selectedDiv = document.getElementById('selectedDatasets');
            
            if (state.selectedDatasets.length > 0) {
                document.getElementById('datasetsPlaceholder').classList.add('hidden');
                selectedSection.classList.remove('hidden');
                selectedDiv.innerHTML = state.selectedDatasets.map(ds => `
                    <div class="p-3 bg-blue-50 dark:bg-blue-900/20 rounded border border-blue-200 dark:border-blue-800 text-sm">
                        <div class="font-medium text-gray-900 dark:text-white mb-1">
                            <a href="${ds.url}" target="_blank" class="hover:underline">${ds.url.split('/').pop()}</a>
                        </div>
                        <div class="text-gray-600 dark:text-gray-400 text-xs">${ds.reason}</div>
                    </div>
                `).join('');
            }

            // Loaded Datasets
            const loadedSection = document.getElementById('loadedDatasetsSection');
            const loadedDiv = document.getElementById('loadedDatasets');
            
            if (state.loadedDatasets.length > 0) {
                loadedSection.classList.remove('hidden');
                loadedDiv.innerHTML = state.loadedDatasets.map(ds => `
                    <div class="p-3 bg-green-50 dark:bg-green-900/20 rounded border border-green-200 dark:border-green-800 text-sm">
                        <div class="font-medium text-gray-900 dark:text-white mb-1">
                            ${ds.tableName} (${ds.rowCount} rows)
                        </div>
                        <div class="text-gray-600 dark:text-gray-400 text-xs">
                            Source: <a href="${ds.fileUrl}" target="_blank" class="hover:underline">${ds.fileUrl.split('/').pop()}</a>
                        </div>
                    </div>
                `).join('');
            }

            // Failed Datasets
            const failedSection = document.getElementById('failedDatasetsSection');
            const failedDiv = document.getElementById('failedDatasets');
            
            if (state.failedDatasets.length > 0) {
                failedSection.classList.remove('hidden');
                failedDiv.innerHTML = state.failedDatasets.map(ds => `
                    <div class="p-3 bg-red-50 dark:bg-red-900/20 rounded border border-red-200 dark:border-red-800 text-sm">
                        <div class="font-medium text-gray-900 dark:text-white mb-1">
                            ${ds.fileUrl.split('/').pop()}
                        </div>
                        <div class="text-red-600 dark:text-red-400 text-xs">${ds.error}</div>
                    </div>
                `).join('');
            }
        }

        function addQuery(sql, explanation, results) {
            state.queries.push({ sql, explanation, results });
            
            const queriesArea = document.getElementById('queriesArea');
            const copyBtn = document.getElementById('copyAllBtn');
            
            queriesArea.querySelector('.italic')?.remove();
            copyBtn.classList.remove('hidden');
            
            const queryDiv = document.createElement('div');
            queryDiv.className = 'p-4 bg-gray-50 dark:bg-gray-700/50 rounded-lg border border-gray-200 dark:border-gray-600';
            queryDiv.innerHTML = `
                <div class="flex items-start justify-between mb-2">
                    <h3 class="text-sm font-semibold text-gray-900 dark:text-white">Query ${state.queries.length}</h3>
                    <button class="copy-query-btn px-2 py-1 text-xs bg-white dark:bg-gray-800 rounded hover:bg-gray-100 dark:hover:bg-gray-700" data-index="${state.queries.length - 1}">
                        Copy
                    </button>
                </div>
                ${explanation ? `<p class="text-xs text-gray-600 dark:text-gray-400 mb-2 italic">${explanation}</p>` : ''}
                <div class="mb-3">
                    <p class="text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">SQL:</p>
                    <pre class="text-xs bg-white dark:bg-gray-800 p-2 rounded border border-gray-200 dark:border-gray-600 overflow-x-auto"><code>${sql}</code></pre>
                </div>
                <div>
                    <p class="text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">Results (${results.length} rows):</p>
                    <pre class="text-xs bg-white dark:bg-gray-800 p-2 rounded border border-gray-200 dark:border-gray-600 overflow-x-auto max-h-48 overflow-y-auto"><code>${JSON.stringify(results.slice(0, 10), null, 2)}${results.length > 10 ? '\n... (' + (results.length - 10) + ' more rows)' : ''}</code></pre>
                </div>
            `;
            
            queriesArea.appendChild(queryDiv);
            
            // Add copy functionality
            queryDiv.querySelector('.copy-query-btn').addEventListener('click', (e) => {
                const idx = parseInt(e.target.dataset.index);
                const q = state.queries[idx];
                const text = `-- Query ${idx + 1}\n-- ${q.explanation || 'SQL Query'}\n${q.sql}\n\n-- Results (${q.results.length} rows)\n${JSON.stringify(q.results, null, 2)}`;
                navigator.clipboard.writeText(text);
                e.target.textContent = 'Copied!';
                setTimeout(() => e.target.textContent = 'Copy', 2000);
            });
        }

        document.getElementById('copyAllBtn').addEventListener('click', () => {
            const text = state.queries.map((q, idx) => 
                `-- Query ${idx + 1}\n-- ${q.explanation || 'SQL Query'}\n${q.sql}\n\n-- Results (${q.results.length} rows)\n${JSON.stringify(q.results, null, 2)}`
            ).join('\n\n' + '='.repeat(80) + '\n\n');
            
            navigator.clipboard.writeText(text);
            const btn = document.getElementById('copyAllBtn');
            btn.textContent = 'Copied!';
            setTimeout(() => btn.textContent = 'Copy All', 2000);
        });

        function setProcessing(isProcessing) {
            state.isProcessing = isProcessing;
            document.getElementById('askBtn').disabled = isProcessing;
            document.getElementById('questionInput').disabled = isProcessing;
            document.getElementById('askBtn').textContent = isProcessing ? 'Processing...' : 'Ask';
        }

        function resetState() {
            state.selectedDatasets = [];
            state.loadedDatasets = [];
            state.failedDatasets = [];
            state.queries = [];
            
            document.getElementById('datasetsPlaceholder').classList.remove('hidden');
            document.getElementById('selectedDatasetsSection').classList.add('hidden');
            document.getElementById('loadedDatasetsSection').classList.add('hidden');
            document.getElementById('failedDatasetsSection').classList.add('hidden');
            
            document.getElementById('queriesArea').innerHTML = '<p class="text-sm text-gray-600 dark:text-gray-400 italic">SQL queries and results will appear here...</p>';
            document.getElementById('copyAllBtn').classList.add('hidden');
        }

        // === Main Query Flow ===
        document.getElementById('askBtn').addEventListener('click', async () => {
            const question = document.getElementById('questionInput').value.trim();
            if (!question || state.isProcessing) return;

            hideError();
            resetState();
            setProcessing(true);

            try {
                // Step 1: Query index
                showStatus('Searching Toronto Open Data index...');
                updateAnswer('*Searching for relevant datasets...*');
                
                const indexPrompt = `Find datasets for: "${question}"

Database: pages table with columns: url, summary
The summary is markdown content from dataset pages.

Generate SQL to find relevant datasets. Return JSON:
{
  "sql": "SELECT url, summary FROM pages WHERE summary LIKE '%keyword%' LIMIT 5",
  "explanation": "why this query"
}`;

                const indexResponse = await callClaude(indexPrompt, '', 'TorontoIndexQuery');
                const indexData = JSON.parse(indexResponse.match(/\{[\s\S]*\}/)[0]);
                
                const indexResults = await executeQuery(indexData.sql);

                if (indexResults.length === 0) {
                    updateAnswer('**No relevant datasets found.** Try rephrasing your question or using different keywords.');
                    setProcessing(false);
                    hideStatus();
                    return;
                }

                // Step 2: Select best datasets
                showStatus('Analyzing datasets...');
                
                const cleanedResults = indexResults.map(r => ({
                    url: r.url,
                    summary: cleanMarkdownSummary(r.summary)
                }));

                const selectionPrompt = `Question: "${question}"

Found datasets:
${JSON.stringify(cleanedResults, null, 2)}

Select the most relevant datasets (max 3). Return JSON:
{
  "datasets": [
    {"url": "...", "reason": "why relevant"}
  ]
}`;

                const selectionResponse = await callClaude(selectionPrompt, '', 'TorontoDataSearch');
                const selection = JSON.parse(selectionResponse.match(/\{[\s\S]*\}/)[0]);
                
                state.selectedDatasets = selection.datasets;
                updateDatasetDisplay();

                // Step 3: Download and convert files
                showStatus('Downloading and converting files...');
                updateAnswer('*Loading selected datasets...*');
                
                for (const dataset of selection.datasets) {
                    const summary = indexResults.find(r => r.url === dataset.url)?.summary || '';
                    const downloadLinks = extractDownloadLinks(summary);
                    
                    if (downloadLinks.length === 0) {
                        state.failedDatasets.push({
                            fileUrl: dataset.url,
                            error: 'No download links found in page'
                        });
                        updateDatasetDisplay();
                        continue;
                    }

                    // Try first download link
                    const fileUrl = downloadLinks[0];

                    try {
                        const convertedJson = await convertWithDocling(fileUrl);
                        
                        // Load into DuckDB
                        const tableName = `dataset_${state.loadedDatasets.length}`;
                        const jsonData = JSON.parse(convertedJson);
                        
                        if (!Array.isArray(jsonData) || jsonData.length === 0) {
                            throw new Error('Invalid JSON format - expected array of objects');
                        }

                        await state.db.registerFileText(`${tableName}.json`, convertedJson);
                        const conn = await state.db.connect();
                        try {
                            await conn.query(`CREATE TABLE ${tableName} AS SELECT * FROM read_json_auto('${tableName}.json')`);
                            const countResult = await conn.query(`SELECT COUNT(*) as count FROM ${tableName}`);
                            const rowCount = countResult.toArray()[0].count;
                            
                            state.loadedDatasets.push({
                                url: dataset.url,
                                tableName,
                                rowCount,
                                fileUrl
                            });
                            updateDatasetDisplay();
                        } finally {
                            await conn.close();
                        }
                    } catch (error) {
                        state.failedDatasets.push({
                            fileUrl,
                            error: error.message
                        });
                        updateDatasetDisplay();
                    }
                }

                if (state.loadedDatasets.length === 0) {
                    updateAnswer('**Failed to load any datasets.** All conversions failed. This might be due to:\n\n- Unsupported file formats\n- Docling API rate limits\n- Network issues\n\nPlease try again or rephrase your question.');
                    showError('All datasets failed to load');
                    setProcessing(false);
                    return;
                }

                // Step 4: Generate and execute SQL queries
                showStatus('Analyzing loaded data...');
                updateAnswer('*Generating SQL queries...*');
                
                const conn = await state.db.connect();
                let schemaInfo = '';
                try {
                    for (const ds of state.loadedDatasets) {
                        const schema = await conn.query(`DESCRIBE ${ds.tableName}`);
                        const cols = schema.toArray();
                        schemaInfo += `\nTable: ${ds.tableName}\nSource: ${ds.url}\nColumns:\n`;
                        cols.forEach(c => {
                            schemaInfo += `  - ${c.column_name}: ${c.column_type}\n`;
                        });
                    }
                } finally {
                    await conn.close();
                }

                const sqlPrompt = `Question: "${question}"

Available tables and schemas:
${schemaInfo}

Generate SQL query to answer the question. Return JSON:
{
  "sql": "SELECT ... FROM dataset_0 ...",
  "explanation": "what this query does and why"
}

Important:
- Use proper SQL syntax for DuckDB
- Handle NULL values appropriately
- Use meaningful column names in results
- Add ORDER BY and LIMIT if appropriate`;

                const sqlResponse = await callClaude(sqlPrompt, '', 'TorontoDataSQL');
                const sqlData = JSON.parse(sqlResponse.match(/\{[\s\S]*\}/)[0]);
                
                showStatus('Executing SQL query...');
                
                const queryResult = await executeQuery(sqlData.sql);
                addQuery(sqlData.sql, sqlData.explanation, queryResult);

                // Step 5: Generate final answer
                showStatus('Generating answer...');
                
                const answerPrompt = `Question: "${question}"

Datasets used:
${state.loadedDatasets.map(ds => `- ${ds.url} (${ds.rowCount} rows, table: ${ds.tableName})`).join('\n')}

SQL Query executed:
${sqlData.sql}

Query explanation:
${sqlData.explanation}

Query results (${queryResult.length} rows):
${JSON.stringify(queryResult, null, 2)}

Provide a comprehensive answer that:
1. **Directly answers the question** based on the data
2. **Highlights key findings** with specific numbers/facts
3. **Explains any limitations** (e.g., data quality, date ranges)
4. **Cites the data sources** used

Use clear markdown formatting with headers, lists, and emphasis where appropriate.`;

                const answer = await callClaude(answerPrompt, '', 'TorontoDataAnswer');
                
                // Add verification section
                const verificationSection = `

---

## ðŸ“Š Verification Information

**Datasets Used:** ${state.loadedDatasets.length} successfully loaded, ${state.failedDatasets.length} failed

**Loaded:**
${state.loadedDatasets.map(ds => `- [${ds.tableName}](${ds.url}) - ${ds.rowCount} rows`).join('\n')}

${state.failedDatasets.length > 0 ? `**Failed:**\n${state.failedDatasets.map(ds => `- ${ds.fileUrl.split('/').pop()} - ${ds.error}`).join('\n')}` : ''}

**SQL Query:** ${state.queries.length} quer${state.queries.length === 1 ? 'y' : 'ies'} executed (see "Queries & Results" panel)

**How to verify:**
1. Click "Copy All" in the Queries & Results panel
2. Load the datasets manually from the links above
3. Run the SQL queries in your own DuckDB instance
4. Compare results with the answer provided`;

                updateAnswer(answer + verificationSection);
                
                hideStatus();
                setProcessing(false);
                
            } catch (error) {
                console.error('Error:', error);
                showError('Error: ' + error.message);
                updateAnswer(`**Error occurred:** ${error.message}\n\nPlease try again or rephrase your question.`);
                setProcessing(false);
            }
        });

        document.getElementById('questionInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !state.isProcessing) {
                document.getElementById('askBtn').click();
            }
        });

        document.getElementById('clearAllBtn').addEventListener('click', async () => {
            if (!confirm('Clear all loaded data and start over?')) return;
            
            const conn = await state.db.connect();
            try {
                for (const ds of state.loadedDatasets) {
                    await conn.query(`DROP TABLE IF EXISTS ${ds.tableName}`);
                }
            } finally {
                await conn.close();
            }
            
            resetState();
            updateAnswer('Your answer will appear here...');
            hideError();
            hideStatus();
        });
    </script>
</body>
</html>
