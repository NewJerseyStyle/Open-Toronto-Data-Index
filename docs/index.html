<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Toronto Open Data QA</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <script src="https://unpkg.com/marked@11.0.0/marked.min.js"></script>
    <style>
        @keyframes pulse-slow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .animate-pulse-slow {
            animation: pulse-slow 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
</head>
<body class="h-full bg-gray-50 dark:bg-gray-900">
    <!-- API Key Modal -->
    <div id="apiKeyModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-8 rounded-lg shadow-xl max-w-md w-full mx-4">
            <h2 class="text-2xl font-bold text-gray-900 dark:text-white mb-4">Welcome!</h2>
            <p class="text-gray-600 dark:text-gray-400 mb-4">
                This app uses Claude to analyze Toronto Open Data. You'll need an Anthropic API key.
            </p>
            
            <div class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4 mb-4">
                <p class="text-sm text-blue-800 dark:text-blue-200">
                    <strong>Get a free key:</strong> 
                    <a href="https://console.anthropic.com/" target="_blank" class="underline hover:text-blue-600">console.anthropic.com</a>
                </p>
            </div>

            <label for="apiKeyInput" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                Anthropic API Key
            </label>
            <input
                type="password"
                id="apiKeyInput"
                placeholder="sk-ant-..."
                class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-[#5D5CDE] dark:bg-gray-700 dark:text-white mb-2"
            >
            <p class="text-xs text-gray-500 dark:text-gray-400 mb-4">
                Your key is stored locally and only sent to Anthropic's API.
            </p>

            <div class="flex justify-end gap-3">
                <button id="apiKeyCancel" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg">
                    Cancel
                </button>
                <button id="apiKeySave" class="px-4 py-2 bg-[#5D5CDE] text-white rounded-lg hover:bg-[#4D4CCE]">
                    Save
                </button>
            </div>
        </div>
    </div>

    <div id="app" class="h-full flex flex-col">
        <!-- Header -->
        <header class="bg-white dark:bg-gray-800 shadow-sm border-b border-gray-200 dark:border-gray-700">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
                <div class="flex items-center justify-between">
                    <div>
                        <h1 class="text-2xl font-bold text-gray-900 dark:text-white">Toronto Open Data QA</h1>
                        <p class="text-sm text-gray-600 dark:text-gray-400 mt-1">AI-powered analysis of Toronto's open datasets</p>
                    </div>
                    <div class="flex gap-2">
                        <button id="changeKeyBtn" class="px-4 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700">
                            Change Key
                        </button>
                        <button id="clearAllBtn" class="px-4 py-2 text-sm border border-red-300 dark:border-red-600 text-red-600 dark:text-red-400 rounded-lg hover:bg-red-50 dark:hover:bg-red-900/20">
                            Clear All
                        </button>
                    </div>
                </div>
            </div>
        </header>

        <!-- Main -->
        <main class="flex-1 overflow-hidden flex flex-col max-w-7xl mx-auto w-full px-4 sm:px-6 lg:px-8 py-6">
            <!-- Question Input -->
            <div class="mb-6">
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-4">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                        Ask a question
                    </label>
                    <div class="flex gap-2">
                        <input
                            type="text"
                            id="questionInput"
                            placeholder="e.g., What are the top 5 most dangerous intersections in Toronto?"
                            class="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-[#5D5CDE] dark:bg-gray-700 dark:text-white"
                        >
                        <button id="askBtn" class="px-6 py-2 bg-[#5D5CDE] text-white rounded-lg hover:bg-[#4D4CCE] disabled:opacity-50">
                            Ask
                        </button>
                    </div>
                </div>
            </div>

            <!-- Status -->
            <div id="statusArea" class="mb-4 hidden">
                <div class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
                    <div class="flex items-start gap-3">
                        <div class="animate-pulse-slow">
                            <svg class="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                        </div>
                        <p id="statusText" class="text-sm text-blue-800 dark:text-blue-200"></p>
                    </div>
                </div>
            </div>

            <!-- Error -->
            <div id="errorArea" class="mb-4 hidden">
                <div class="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4">
                    <div class="flex items-start gap-3">
                        <svg class="w-5 h-5 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                        <p id="errorText" class="text-sm text-red-800 dark:text-red-200"></p>
                    </div>
                </div>
            </div>

            <!-- Two Column Layout -->
            <div class="flex-1 grid grid-cols-1 lg:grid-cols-2 gap-6 overflow-hidden">
                <!-- Left: Answer -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6 overflow-auto">
                    <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Answer</h2>
                    <div id="answerArea" class="prose prose-sm dark:prose-invert max-w-none">
                        <p class="text-gray-600 dark:text-gray-400 italic">Your answer will appear here...</p>
                    </div>
                </div>

                <!-- Right: Process Log -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6 overflow-auto">
                    <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Process Log</h2>
                    <div id="processLog" class="space-y-3 text-sm">
                        <p class="text-gray-600 dark:text-gray-400 italic">Process steps will appear here...</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script type="module">
        import * as duckdb from 'https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.30.0/+esm';
        
        window.duckdb = duckdb;
        marked.setOptions({ breaks: true, gfm: true });

        const state = {
            db: null,
            apiKey: null,
            isProcessing: false,
            loadedDatasets: []
        };

        // === API Key Management ===
        function showApiKeyModal() {
            document.getElementById('apiKeyModal').classList.remove('hidden');
            document.getElementById('apiKeyInput').focus();
        }

        function hideApiKeyModal() {
            document.getElementById('apiKeyModal').classList.add('hidden');
        }

        function saveApiKey() {
            const key = document.getElementById('apiKeyInput').value.trim();
            if (!key || !key.startsWith('sk-ant-')) {
                alert('Please enter a valid API key starting with "sk-ant-"');
                return;
            }
            localStorage.setItem('anthropic_api_key', key);
            state.apiKey = key;
            hideApiKeyModal();
            initDuckDB();
        }

        window.addEventListener('DOMContentLoaded', () => {
            const savedKey = localStorage.getItem('anthropic_api_key');
            if (savedKey) {
                state.apiKey = savedKey;
                initDuckDB();
            } else {
                showApiKeyModal();
            }
        });

        document.getElementById('apiKeySave').addEventListener('click', saveApiKey);
        document.getElementById('apiKeyCancel').addEventListener('click', () => {
            if (!state.apiKey) alert('An API key is required');
            else hideApiKeyModal();
        });
        document.getElementById('apiKeyInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') saveApiKey();
        });
        document.getElementById('changeKeyBtn').addEventListener('click', showApiKeyModal);

        // === Claude API ===
        async function callClaude(prompt, systemPrompt = '', useSystemPromptFile = null) {
            if (!state.apiKey) throw new Error('No API key');

            // If system prompt file specified, fetch it
            let finalSystemPrompt = systemPrompt;
            if (useSystemPromptFile) {
                try {
                    const response = await fetch(`prompts/${useSystemPromptFile}.md`);
                    if (response.ok) {
                        finalSystemPrompt = await response.text();
                    }
                } catch (e) {
                    console.warn('Could not load system prompt file:', e);
                }
            }

            const response = await fetch("https://api.anthropic.com/v1/messages", {
                method: "POST",
                headers: {
                    "x-api-key": state.apiKey,
                    "anthropic-version": "2023-06-01",
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({
                    model: "claude-sonnet-4-20250514",
                    max_tokens: 4000,
                    messages: [{ role: "user", content: prompt }],
                    ...(finalSystemPrompt && { system: finalSystemPrompt })
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || 'API call failed');
            }

            const data = await response.json();
            return data.content[0].text;
        }

        // === DuckDB ===
        async function initDuckDB() {
            try {
                showStatus('Initializing database...');

                const JSDELIVR_BUNDLES = window.duckdb.getJsDelivrBundles();
                const bundle = await window.duckdb.selectBundle(JSDELIVR_BUNDLES);
                const worker = await window.duckdb.createWorker(bundle.mainWorker);
                const logger = new window.duckdb.ConsoleLogger();
                const db = new window.duckdb.AsyncDuckDB(logger, worker);
                await db.instantiate(bundle.mainModule, bundle.pthreadWorker);

                state.db = db;
                
                const conn = await db.connect();
                try {
                    await conn.query("INSTALL httpfs; LOAD httpfs;");
                    await conn.query(`
                        ATTACH 'https://cdn.jsdelivr.net/gh/NewJerseyStyle/Open-Toronto-Data-Index/opendata.db' AS toronto_db;
                        USE toronto_db;
                    `);
                    
                    // Check actual schema
                    const schemaResult = await conn.query("PRAGMA table_info(pages)");
                    console.log('Index schema:', schemaResult.toArray());
                } finally {
                    await conn.close();
                }
                
                hideStatus();
                addLog('✓ Database ready', 'success');
                updateAnswer('**Ready!** Ask a question about Toronto open data.');
            } catch (error) {
                console.error('Init error:', error);
                showError('Failed to initialize: ' + error.message);
            }
        }

        async function executeQuery(sql) {
            const conn = await state.db.connect();
            try {
                const result = await conn.query(sql);
                return result.toArray();
            } finally {
                await conn.close();
            }
        }

        // === Docling Conversion ===
        async function convertWithDocling(fileUrl) {
            addLog(`Converting file with Docling: ${fileUrl}`, 'info');
            
            try {
                // POST request to start conversion
                const postResponse = await fetch('https://yasserrmd-doclingconverter.hf.space/gradio_api/call/convert_document', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        data: [
                            { path: fileUrl },
                            "Markdown"
                        ]
                    })
                });

                const postData = await postResponse.json();
                const eventId = postData.event_id;
                
                if (!eventId) throw new Error('No event ID returned from Docling');

                addLog(`Waiting for conversion (Event ID: ${eventId})...`, 'info');

                // GET request to fetch result
                const getResponse = await fetch(`https://yasserrmd-doclingconverter.hf.space/gradio_api/call/convert_document/${eventId}`);
                
                const reader = getResponse.body.getReader();
                const decoder = new TextDecoder();
                let result = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                if (data[0]) result = data[0];
                            } catch (e) {
                                // Ignore parse errors
                            }
                        }
                    }
                }

                if (!result) throw new Error('No result from Docling');
                
                addLog('✓ File converted successfully', 'success');
                return result;
            } catch (error) {
                addLog(`✗ Docling conversion failed: ${error.message}`, 'error');
                throw error;
            }
        }

        // === Helper Functions ===
        function cleanMarkdownSummary(markdown) {
            // Remove common repeated sections
            const lines = markdown.split('\n');
            const seen = new Set();
            const cleaned = [];
            
            for (const line of lines) {
                const trimmed = line.trim();
                // Skip empty lines, common headers, footers
                if (!trimmed) continue;
                if (trimmed.match(/^(toronto|city of toronto|open data|dataset|download|share)/i)) continue;
                if (seen.has(trimmed)) continue;
                
                seen.add(trimmed);
                cleaned.push(line);
            }
            
            return cleaned.join('\n');
        }

        function extractDownloadLinks(markdown) {
            // Extract [Download (...)] links
            const links = [];
            const regex = /\[Download\s+\([^\)]+\)\]\((https?:\/\/[^\)]+)\)/gi;
            let match;
            
            while ((match = regex.exec(markdown)) !== null) {
                links.push(match[1]);
            }
            
            return links;
        }

        function showStatus(msg) {
            document.getElementById('statusText').textContent = msg;
            document.getElementById('statusArea').classList.remove('hidden');
        }

        function hideStatus() {
            document.getElementById('statusArea').classList.add('hidden');
        }

        function showError(msg) {
            document.getElementById('errorText').textContent = msg;
            document.getElementById('errorArea').classList.remove('hidden');
        }

        function hideError() {
            document.getElementById('errorArea').classList.add('hidden');
        }

        function updateAnswer(text) {
            document.getElementById('answerArea').innerHTML = marked.parse(text);
        }

        function addLog(message, type = 'info') {
            const logArea = document.getElementById('processLog');
            const colors = {
                info: 'text-blue-700 dark:text-blue-300',
                success: 'text-green-700 dark:text-green-300',
                error: 'text-red-700 dark:text-red-300',
                warning: 'text-yellow-700 dark:text-yellow-300'
            };
            
            const logEntry = document.createElement('div');
            logEntry.className = `p-2 rounded ${colors[type]} bg-gray-50 dark:bg-gray-700/50`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            
            if (logArea.querySelector('.italic')) {
                logArea.innerHTML = '';
            }
            
            logArea.appendChild(logEntry);
            logArea.scrollTop = logArea.scrollHeight;
        }

        function clearLog() {
            document.getElementById('processLog').innerHTML = '<p class="text-gray-600 dark:text-gray-400 italic">Process steps will appear here...</p>';
        }

        function setProcessing(isProcessing) {
            state.isProcessing = isProcessing;
            document.getElementById('askBtn').disabled = isProcessing;
            document.getElementById('questionInput').disabled = isProcessing;
            document.getElementById('askBtn').textContent = isProcessing ? 'Processing...' : 'Ask';
        }

        // === Main Query Flow ===
        document.getElementById('askBtn').addEventListener('click', async () => {
            const question = document.getElementById('questionInput').value.trim();
            if (!question || state.isProcessing) return;

            hideError();
            clearLog();
            setProcessing(true);

            try {
                // Step 1: Query index
                addLog('Searching Toronto Open Data index...', 'info');
                showStatus('Searching index...');
                
                const indexPrompt = `Find datasets for: "${question}"

Database: pages table with columns: url, summary
The summary is markdown content from dataset pages.

Generate SQL to find relevant datasets. Return JSON:
{
  "sql": "SELECT url, summary FROM pages WHERE summary LIKE '%keyword%' LIMIT 5",
  "explanation": "why this query"
}`;

                const indexResponse = await callClaude(indexPrompt, '', 'TorontoIndexQuery');
                const indexData = JSON.parse(indexResponse.match(/\{[\s\S]*\}/)[0]);
                
                addLog(`Generated SQL: ${indexData.sql}`, 'info');
                
                const indexResults = await executeQuery(indexData.sql);
                addLog(`Found ${indexResults.length} potential datasets`, 'success');

                if (indexResults.length === 0) {
                    updateAnswer('No relevant datasets found. Try rephrasing your question.');
                    setProcessing(false);
                    hideStatus();
                    return;
                }

                // Step 2: Select best datasets
                showStatus('Selecting relevant datasets...');
                
                const cleanedResults = indexResults.map(r => ({
                    url: r.url,
                    summary: cleanMarkdownSummary(r.summary)
                }));

                const selectionPrompt = `Question: "${question}"

Found datasets:
${JSON.stringify(cleanedResults, null, 2)}

Select the most relevant datasets (max 3). Return JSON:
{
  "datasets": [
    {"url": "...", "reason": "why relevant"}
  ]
}`;

                const selectionResponse = await callClaude(selectionPrompt, '', 'TorontoDataSearch');
                const selection = JSON.parse(selectionResponse.match(/\{[\s\S]*\}/)[0]);
                
                addLog(`Selected ${selection.datasets.length} datasets`, 'success');

                // Step 3: Download and convert files
                showStatus('Downloading and converting files...');
                
                for (const dataset of selection.datasets) {
                    const summary = indexResults.find(r => r.url === dataset.url)?.summary || '';
                    const downloadLinks = extractDownloadLinks(summary);
                    
                    if (downloadLinks.length === 0) {
                        addLog(`No download links found for ${dataset.url}`, 'warning');
                        continue;
                    }

                    // Try first download link
                    const fileUrl = downloadLinks[0];
                    addLog(`Processing: ${fileUrl}`, 'info');

                    try {
                        const convertedJson = await convertWithDocling(fileUrl);
                        
                        // Load into DuckDB
                        const tableName = `dataset_${state.loadedDatasets.length}`;
                        const jsonData = JSON.parse(convertedJson);
                        
                        if (!Array.isArray(jsonData) || jsonData.length === 0) {
                            throw new Error('Invalid JSON format');
                        }

                        await state.db.registerFileText(`${tableName}.json`, convertedJson);
                        const conn = await state.db.connect();
                        try {
                            await conn.query(`CREATE TABLE ${tableName} AS SELECT * FROM read_json_auto('${tableName}.json')`);
                            const countResult = await conn.query(`SELECT COUNT(*) as count FROM ${tableName}`);
                            const rowCount = countResult.toArray()[0].count;
                            
                            state.loadedDatasets.push({
                                url: dataset.url,
                                tableName,
                                rowCount
                            });
                            
                            addLog(`✓ Loaded ${rowCount} rows into ${tableName}`, 'success');
                        } finally {
                            await conn.close();
                        }
                    } catch (error) {
                        addLog(`Failed to load dataset: ${error.message}`, 'error');
                    }
                }

                if (state.loadedDatasets.length === 0) {
                    showError('Failed to load any datasets');
                    setProcessing(false);
                    return;
                }

                // Step 4: Generate and execute SQL
                showStatus('Generating SQL query...');
                
                const conn = await state.db.connect();
                let schemaInfo = '';
                try {
                    for (const ds of state.loadedDatasets) {
                        const schema = await conn.query(`DESCRIBE ${ds.tableName}`);
                        schemaInfo += `\nTable ${ds.tableName}:\n${schema.toArray().map(c => `  ${c.column_name}: ${c.column_type}`).join('\n')}\n`;
                    }
                } finally {
                    await conn.close();
                }

                const sqlPrompt = `Question: "${question}"

Available tables:
${schemaInfo}

Generate SQL to answer the question. Return JSON:
{
  "sql": "SELECT ...",
  "explanation": "what this query does"
}`;

                const sqlResponse = await callClaude(sqlPrompt, '', 'TorontoDataSQL');
                const sqlData = JSON.parse(sqlResponse.match(/\{[\s\S]*\}/)[0]);
                
                addLog(`Generated SQL: ${sqlData.sql}`, 'info');
                showStatus('Executing query...');
                
                const queryResult = await executeQuery(sqlData.sql);
                addLog(`Query returned ${queryResult.length} rows`, 'success');

                // Step 5: Generate answer
                showStatus('Generating answer...');
                
                const answerPrompt = `Question: "${question}"

SQL Query: ${sqlData.sql}

Results:
${JSON.stringify(queryResult, null, 2)}

Provide a clear, well-formatted answer with:
1. Direct answer to the question
2. Key insights from the data
3. Any important caveats

Use markdown formatting.`;

                const answer = await callClaude(answerPrompt, '', 'TorontoDataAnswer');
                updateAnswer(answer);
                
                hideStatus();
                setProcessing(false);
                addLog('✓ Analysis complete', 'success');
                
            } catch (error) {
                console.error('Error:', error);
                showError('Error: ' + error.message);
                addLog(`✗ Error: ${error.message}`, 'error');
                setProcessing(false);
            }
        });

        document.getElementById('questionInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !state.isProcessing) {
                document.getElementById('askBtn').click();
            }
        });

        document.getElementById('clearAllBtn').addEventListener('click', async () => {
            if (!confirm('Clear all data?')) return;
            
            const conn = await state.db.connect();
            try {
                for (const ds of state.loadedDatasets) {
                    await conn.query(`DROP TABLE IF EXISTS ${ds.tableName}`);
                }
            } finally {
                await conn.close();
            }
            
            state.loadedDatasets = [];
            clearLog();
            updateAnswer('Your answer will appear here...');
            hideError();
            hideStatus();
        });
    </script>
</body>
</html>
